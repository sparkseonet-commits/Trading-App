// src/app/App.jsx
import React, { useMemo, useState, useCallback } from "react";
import Papa from "papaparse";
import "./app.css";

import { ABSOLUTE_CAP, BLENDED_CAP, BARS_PER_DAY, MS_PER_DAY, SYNC_ID, DEFAULT_WEIGHTS } from "./constants";
import { parseHeadered, parseBinance } from "../data/parse";
import { resampleDaily, aggregate4h } from "../data/resample";
import { computeDailyIndicators, expandDaily } from "../indicators/daily";
import { buildSignals } from "../engine/signals";
import { scoreBar } from "../engine/score";

import PriceChart from "../charts/PriceChart";
import RsiChart from "../charts/RsiChart";
import MacdChart from "../charts/MacdChart";
import BuyTable from "../charts/BuyTable";

// Simple error boundary to prevent white screen on runtime errors
class ErrorBoundary extends React.Component {
  constructor(props){
    super(props);
    this.state = { hasError: false, message: "" };
  }
  static getDerivedStateFromError(error){
    return { hasError: true, message: String(error?.message || error) };
  }
  componentDidCatch(error, info){
    // eslint-disable-next-line no-console
    console.error("ErrorBoundary:", error, info);
  }
  render(){
    if (this.state.hasError){
      return (
        <div style={{ padding: 16, color: "#991b1b", background: "#fef2f2", border: "1px solid #fecaca", borderRadius: 12 }}>
          <b>Something went wrong while rendering.</b>
          <div style={{ marginTop: 6, fontFamily: "ui-monospace, SFMono-Regular, Menlo, monospace", whiteSpace: "pre-wrap" }}>{this.state.message}</div>
        </div>
      );
    }
    return this.props.children;
  }
}

function useParsedRows(format){
  const [rows, setRows] = useState([]);
  const [filename, setFilename] = useState("");
  const [lastError, setLastError] = useState(null);

  const onFile = useCallback((f)=>{
    if (!f) return;
    setFilename(f.name);
    Papa.parse(f, {
      header: format === "headered",
      dynamicTyping: true,
      skipEmptyLines: true,
      complete: (res)=>{
        try {
          const parsed = (format === "headered") ? parseHeadered(res.data) : parseBinance(res.data);
          setRows(parsed);
          setLastError(null);
          // eslint-disable-next-line no-console
          console.log("Parsed rows:", parsed.length, parsed[0]);
        } catch(e){
          // eslint-disable-next-line no-console
          console.error(e);
          setLastError(String(e?.message || e));
          setRows([]);
        }
      }
    });
  }, [format]);

  return { rows, onFile, filename, lastError };
}

function sampleTo4h(tsSeries, valSeries){
  const FOUR_H = 4 * 60 * 60 * 1000;
  const out = [];
  if (!tsSeries?.length) return out;
  let bucket = Math.floor(tsSeries[0] / FOUR_H) * FOUR_H;
  let last = null;
  for (let i=0;i<tsSeries.length;i++){
    const t = tsSeries[i];
    const k = Math.floor(t / FOUR_H) * FOUR_H;
    if (k !== bucket){
      out.push({ ts4h: bucket, value: last });
      bucket = k;
    }
    last = valSeries[i];
  }
  out.push({ ts4h: bucket, value: last });
  return out;
}

export default function App(){
  // --- HEADER ---
  const [format, setFormat] = useState("binance"); // 'headered' | 'binance'
  const { rows, onFile, filename, lastError } = useParsedRows(format);

  // --- SCORING CONTROLS ---
  const [threshold, setThreshold] = useState(80);     // Master threshold
  const [maxBuyWindowH, setMaxBuyWindowH] = useState(720); // window to confirm peaks
  const [cooldownH, setCooldownH] = useState(720);    // spacing between buys
  const [visibleDays, setVisibleDays] = useState(365);
  const [offsetDays, setOffsetDays] = useState(0);
  const [weights, setWeights] = useState(DEFAULT_WEIGHTS);
  const setWeight = (key) => (v) => setWeights((w)=> ({ ...w, [key]: v }));

  // --- DAILY INDICATORS + EXPANSION ---
  const dailyBundle = useMemo(()=>{
    try {
      if (!rows.length) return null;
      const { daily, rowToDay } = resampleDaily(rows);
      const d = computeDailyIndicators(daily, rows);
      const expand = (arr)=> expandDaily(arr, rowToDay);
      return {
        daily, rowToDay,
        dBBlowerRow:   expand(d.dBBlower),
        dRSIRow:       expand(d.dRSI),
        dMACDRow:      expand(d.dMACD),
        dMACDSigRow:   expand(d.dMACDsig),
        dMACDCrossRow: expand(d.dMACDCross).map(Boolean),
        dSMA7Row:      expand(d.dSMA7),
        dSMA30Row:     expand(d.dSMA30),
        dSMA90Row:     expand(d.dSMA90),
        dSmaStackRow:  expand(d.dSmaStack).map(Boolean),
        dPrev30LowUpRow: expand(d.dPrev30LowUp).map(Boolean),
        dPiBuyRow:     expand(d.dPiBuy),
        dPiRatioRow:   expand(d.dPiRatio),
        rMvrvBuyRow:   d.rMvrvBuy
      };
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("dailyBundle error", e);
      return null;
    }
  }, [rows]);

  // --- 1H SIGNALS ---
  const sig = useMemo(()=>{
    if (!rows.length || !dailyBundle) return null;
    return buildSignals(rows, {
      dBBlowerRow: dailyBundle.dBBlowerRow,
      dRSIRow:     dailyBundle.dRSIRow,
      dMACDRow:    dailyBundle.dMACDRow,
      dMACDSigRow: dailyBundle.dMACDSigRow,
      dMACDCrossRow: dailyBundle.dMACDCrossRow,
      dSMA7Row:    dailyBundle.dSMA7Row,
      dSMA30Row:   dailyBundle.dSMA30Row,
      dSMA90Row:   dailyBundle.dSMA90Row,
      dSmaStackRow: dailyBundle.dSmaStackRow,
      dPrev30LowUpRow: dailyBundle.dPrev30LowUpRow,
      dPiBuyRow:   dailyBundle.dPiBuyRow,
      dPiRatioRow: dailyBundle.dPiRatioRow,
      rMvrvBuyRow: dailyBundle.rMvrvBuyRow
    });
  }, [rows, dailyBundle]);

  // --- WINDOWING + SCORING + 4H AGG ---
  const view = useMemo(()=>{
    try {
      if (!rows.length || !sig) return null;

      const firstTs = rows[0].ts, lastTs = rows[rows.length-1].ts;
      const maxSpanDays = Math.max(1, Math.floor((lastTs - firstTs)/MS_PER_DAY));
      const wndDays = Math.min(visibleDays, maxSpanDays);
      const offsetClamped = Math.min(Math.max(0, offsetDays), Math.max(0, maxSpanDays - wndDays));

      const startTs = Math.max(firstTs, lastTs - (offsetClamped + wndDays) * MS_PER_DAY);
      const endTs   = Math.min(lastTs, startTs + wndDays * MS_PER_DAY);
      const s = rows.findIndex(r => r.ts >= startTs);
      const eIdx   = rows.findIndex(r => r.ts > endTs);
      const e = eIdx === -1 ? rows.length : eIdx;

      // slice
      const ctx = {
        piBuy:      sig.absolutes.piBuy.slice(s,e),
        mvrvzBuy:   sig.absolutes.mvrvzBuy.slice(s,e),
        touchLower: sig.features.touchLower.slice(s,e),
        macdCross:  sig.series.macdCross.slice(s,e),
        rsi:        sig.series.rsiRow.slice(s,e),
        vsa:        sig.features.vsaC.slice(s,e),
        smaStack:   sig.series.smaStack.slice(s,e),
        prevLowUp:  sig.series.prev30LowUp.slice(s,e),
        piDeep:     sig.features.piRatioRow.slice(s,e).map(v=> Number.isFinite(v) && v < 0.125),
        weights
      };

      const visRows = rows.slice(s,e);
      const n = visRows.length;
      const conf = new Array(n).fill(0);
      const partsArr = new Array(n).fill(null);

      for (let i=0;i<n;i++){
        const { confidence, parts } = scoreBar(i, ctx);
        conf[i] = confidence; partsArr[i] = parts;
      }

      // buys with both window & cooldown
      const windowMs = maxBuyWindowH * 60 * 60 * 1000;
      const cooldownMs = cooldownH * 60 * 60 * 1000;
      const buys = [];
      let lastBuyTs = -Infinity;
      for (let i=1;i<n;i++){
        const ts = visRows[i].ts;
        const cross = conf[i] >= threshold && conf[i-1] < threshold; // cross up
        if (cross){
          // ensure window peak
          const cutoff = ts + windowMs;
          let isPeak = true;
          for (let j=i+1; j<n && visRows[j].ts <= cutoff; j++){
            if (conf[j] > conf[i]) { isPeak = false; break; }
          }
          if (isPeak && ts - lastBuyTs >= cooldownMs){
            buys.push({ ts, confidence: conf[i], parts: partsArr[i] });
            lastBuyTs = ts;
          }
        }
      }

      // 4h data
      const { data: display4h } = aggregate4h(visRows);
      const pi4h   = sampleTo4h(visRows.map(r=>r.ts), sig.features.piRatioRow).map(p=> ({ ts4h: p.ts4h, pi: p.value }));
      const rsi4h  = sampleTo4h(visRows.map(r=>r.ts), sig.series.rsiRow).map(p=> ({ ts4h: p.ts4h, rsi: p.value }));
      const macd4h = sampleTo4h(visRows.map(r=>r.ts), sig.series.macdRow).map(p=> ({ ts4h: p.ts4h, macd: p.value }));
      const macdSig4h = sampleTo4h(visRows.map(r=>r.ts), sig.series.macdSigRow).map(p=> ({ ts4h: p.ts4h, signal: p.value }));
      const macdMerged = macd4h.map((m,i)=> ({ ts4h: m.ts4h, macd: m.value, signal: macdSig4h[i]?.signal }));

      const FOUR_H = 4 * 60 * 60 * 1000;
      const buyLines4h = Array.from(new Set(buys.map(b=> Math.floor(b.ts/FOUR_H)*FOUR_H))).sort((a,b)=>a-b);

      return { firstTs, lastTs, visRows, conf, buys, display4h, buyLines4h, rsi4h, macd4h: macdMerged, pi4h };
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("view compute error", e);
      return null;
    }
  }, [rows, sig, visibleDays, offsetDays, threshold, maxBuyWindowH, cooldownH, weights]);

  // --- RENDER ---
  return (
    <ErrorBoundary>
      <div className="page">
        <header className="top">
          <h2>Crypto Confidence Backtester</h2>
          <div className="upload">
            <div className="toggle">
              <label><input type="radio" checked={format==='headered'} onChange={()=>setFormat('headered')} /> Headered CSV</label>
              <label><input type="radio" checked={format==='binance'} onChange={()=>setFormat('binance')} /> Binance Kline CSV</label>
            </div>
            <label className="button">
              <input type="file" accept=".csv,text/csv" onChange={(e)=> onFile(e.target.files?.[0]) } style={{ display: 'none' }} />
              <span>Choose CSV</span>
            </label>
            {filename && <div className="filename">{filename}</div>}
          </div>
        </header>

        {rows.length > 0 && (
          <div className="meta">First: {new Date(rows[0].ts).toISOString()} | Last: {new Date(rows[rows.length-1].ts).toISOString()}</div>
        )}

        <div className="grid">
          <section className="panel">
            <h3>Scoring Controls</h3>
            <Slider label={`Master threshold: ${threshold}`} min={1} max={100} step={1} value={threshold} setValue={setThreshold} />
            <Slider label={`Max buy window (hours): ${maxBuyWindowH}`} min={1} max={1440} step={1} value={maxBuyWindowH} setValue={setMaxBuyWindowH} />
            <p className="muted">Cooldown between buys (e.g. 720 ≈ 30 days).</p>
            <Slider label={`Cooldown between buys (hours): ${cooldownH}`} min={1} max={1440} step={1} value={cooldownH} setValue={setCooldownH} />
            <Slider label={`Visible window (days): ${visibleDays}`} min={7} max={720} step={1} value={visibleDays} setValue={setVisibleDays} />
            <Slider label={`Offset from end (days): ${offsetDays}`} min={0} max={365} step={1} value={offsetDays} setValue={setOffsetDays} />
          </section>

          <section className="panel">
            <h3>Price</h3>
            {view && (
              <PriceChart
                data={mergeSeries(view.display4h, view.pi4h, (a,b)=> ({...a, ...b}))}
                buys={view.buyLines4h}
                syncId={SYNC_ID}
              />
            )}
          </section>

          <section className="panel">
            <h3>Weights</h3>
            <Slider label={`bollinger`} min={0} max={3} step={0.05} value={weights.bollinger} setValue={setWeight('bollinger')} />
            <Slider label={`macd`} min={0} max={3} step={0.05} value={weights.macd} setValue={setWeight('macd')} />
            <Slider label={`vsa`} min={0} max={3} step={0.05} value={weights.vsa} setValue={setWeight('vsa')} />
            <Slider label={`smaStack`} min={0} max={3} step={0.05} value={weights.smaStack} setValue={setWeight('smaStack')} />
            <Slider label={`prevLowUp`} min={0} max={3} step={0.05} value={weights.prevLowUp} setValue={setWeight('prevLowUp')} />
            <div className="subtle">RSI band weights</div>
            <Slider label={`rsi10`} min={0} max={3} step={0.05} value={weights.rsi10} setValue={setWeight('rsi10')} />
            <Slider label={`rsi20`} min={0} max={3} step={0.05} value={weights.rsi20} setValue={setWeight('rsi20')} />
            <Slider label={`rsi30`} min={0} max={3} step={0.05} value={weights.rsi30} setValue={setWeight('rsi30')} />
            <div className="subtle">Experimental</div>
            <Slider label={`PI deep-buy (PI < 0.125)`} min={0} max={3} step={0.05} value={weights.piDeep} setValue={setWeight('piDeep')} />
            <p className="muted">Absolute: PI ≤ 0.30, MVRV-Z ≤ 0 → confidence 100.</p>
          </section>

          <section className="panel">
            <h3>RSI (14d)</h3>
            {view && <RsiChart data={view.rsi4h} buys={view.buyLines4h} syncId={SYNC_ID} />}
          </section>

          <section className="panel">
            <h3>MACD</h3>
            {view && <MacdChart data={view.macd4h} buys={view.buyLines4h} syncId={SYNC_ID} />}
          </section>
        </div>

        <section className="panel">
          <h3>Buy Signals</h3>
          {view ? <BuyTable buys={view.buys} /> : (
            <div className="muted" style={{ padding: 8 }}>
              {lastError ? `Error: ${lastError}` : "Load a CSV to see results."}
            </div>
          )}
        </section>
      </div>
    </ErrorBoundary>
  );
}

function Slider({ label, value, setValue, min=0, max=100, step=1 }){
  return (
    <label className="slider">
      <div className="label">{label}</div>
      <input type="range" min={min} max={max} step={step} value={value} onChange={(e)=> setValue(Number(e.target.value))} />
    </label>
  );
}

function mergeSeries(base, overlay, combiner){
  if (!Array.isArray(base) || !Array.isArray(overlay)) return base || [];
  const map = new Map(overlay.map(o=> [o.ts4h, o]));
  return base.map(b => {
    const o = map.get(b.ts4h);
    return o ? combiner(b, o) : b;
  });
}
